#!/usr/bin/env bash
# Usage: bin/compile <build-dir> <cache-dir> <env-dir>
# See: https://devcenter.heroku.com/articles/buildpack-api

set -euo pipefail

BUILD_DIR="${1}"
ENV_DIR="${3}"

DOTNET_CNB_VERSION="0.11.2"

BUILDPACK_DIR=$(cd "$(dirname "$(dirname "${BASH_SOURCE[0]}")")" && pwd)

source "${BUILDPACK_DIR:?}/lib/output.sh"
source "${BUILDPACK_DIR:?}/vendor/buildpack-stdlib_v8.sh"

CNB_BUILD_DIR="/app/.heroku/cnb/dotnet"
PROFILE_PATH="${BUILD_DIR}/.profile.d/dotnet.sh"

initialize_environment() {
	export_env "${ENV_DIR}" "." ""
	mkdir -p "$(dirname "${PROFILE_PATH}")"
	mkdir -p "${BUILD_DIR}/.heroku/cnb/dotnet"
	mkdir -p "$(dirname "${CNB_BUILD_DIR}")"

	# Create "/app/.heroku/cnb/dotnet" symlink to the actual build directory.
	# This allows the CNB to write path environment variables that work both at
	# runtime and during the build.
	ln -nsf "${BUILD_DIR}/.heroku/cnb/dotnet" "${CNB_BUILD_DIR}"
	touch "${CNB_BUILD_DIR}/buildpack_plan.toml"
	mkdir -p "${CNB_BUILD_DIR}"/{layers,platform}

	export CNB_BUILDPACK_DIR="${BUILDPACK_DIR}/cnb"
	export CNB_TARGET_OS="linux"
	local arch
	arch=$(dpkg --print-architecture)
	export CNB_TARGET_ARCH="${arch}"
	export CNB_TARGET_DISTRO_NAME="ubuntu"
	# shellcheck disable=SC2154 # TODO: Env var is referenced but not assigned.
	# Support both Heroku and Scalingo stack naming conventions
	if [[ "${STACK}" =~ ^heroku- ]]; then
		export CNB_TARGET_DISTRO_VERSION="${STACK/heroku-/}.04"
	elif [[ "${STACK}" =~ ^scalingo- ]]; then
		export CNB_TARGET_DISTRO_VERSION="${STACK/scalingo-/}.04"
	else
		# Default to 22.04 for unknown stacks
		export CNB_TARGET_DISTRO_VERSION="22.04"
	fi

	cd "${BUILD_DIR}"
}

download_and_extract_cnb() {
	local buildpack_url="https://github.com/heroku/buildpacks-dotnet/releases/download/v${DOTNET_CNB_VERSION}/heroku_dotnet_${CNB_TARGET_OS}-${CNB_TARGET_ARCH}.cnb"
	local temp_dir
	temp_dir=$(mktemp -d)
	# Download the CNB, modifying file paths to remove leading '/' during extraction
	if ! curl --silent --show-error --location --fail --retry 3 --retry-connrefused --connect-timeout 10 "${buildpack_url}" | tar --transform 's|^/||' --extract --directory "${temp_dir}"; then
		output::error <<-EOF
			Error: Failed to download/extract buildpack from GitHub:
			${buildpack_url}

			In some cases, this happens due to an unstable network,
			or GitHub's API/CDN.

			Please try again to see if the error resolves itself.

			If that doesn't help, check the status of GitHub here:
			https://www.githubstatus.com
		EOF
		exit 1
	fi

	local manifest_digest
	manifest_digest=$(jq -r '.manifests[0].digest' "${temp_dir}/index.json")
	local manifest_file="${temp_dir}/blobs/sha256/${manifest_digest#sha256:}"

	# Prepare the target directory and extract layers from the manifest file
	mkdir -p "${CNB_BUILDPACK_DIR}"

	jq -r --exit-status '.layers[].digest' "${manifest_file}" | while read -r layer_digest; do
		# Extract each layer, modifying file paths to remove leading '/', and
		# removing the nested prefix directories (e.g. `cnb/buildpacks/heroku_dotnet/0.1.6`)
		tar --transform 's|^/||' --strip-components=4 -xf "${temp_dir}/blobs/sha256/${layer_digest#sha256:}" -C "${CNB_BUILDPACK_DIR}"
	done
}

# Function to format CNB output, rewriting section prefixes to classic
# buildpack output style.
# TODO: Remove when the CNB supports printing classic output style natively.
format_cnb_output() {
	local skip_next=true # Set to true to avoid leading newline from CNB
	while IFS= read -r line; do
		if ${skip_next}; then
			skip_next=false
			continue
		fi
		if [[ ${line} == *"## Heroku .NET Buildpack"* ]]; then
			skip_next=true # Skip trailing whitespace
			continue       # Drop this line
		fi
		local color_code=''
		local clean_line="${line}"

		# Detect and store ANSI color code at the start of the line, if present
		if [[ "${line}" =~ ^($'\x1b['[0-9;]*'m') ]]; then
			color_code="${BASH_REMATCH[1]}"
			clean_line="${line#"${color_code}"}" # Remove color code for pattern matching
		fi

		# Set prefix and content based on line pattern
		case "${clean_line}" in
			"##"*)
				prefix='----->'
				content="${clean_line:2}"
				;;
			"-"*)
				prefix='----->'
				content="${clean_line:1}"
				;;
			"  -"*)
				prefix='      '
				content="${clean_line:3}"
				;;
			"!"*)
				prefix=' !    '
				content="${clean_line:1}"
				;;
			"")
				prefix=''
				content=''
				;;
			*)
				prefix='   '
				content="${clean_line}"
				;;
		esac
		echo "${color_code}${prefix}${content}"
	done
}

# Run CNB bin/build with formatted output
run_build() {
	"${CNB_BUILDPACK_DIR}/bin/build" "${CNB_BUILD_DIR}/layers" "${CNB_BUILD_DIR}/platform" "${CNB_BUILD_DIR}/buildpack_plan.toml" |& format_cnb_output
}

# Purge non-launch layers to reduce slug size
remove_non_launch_layers() {
	for layer_toml in "${CNB_BUILD_DIR}/layers/"*.toml; do
		case "$(basename "${layer_toml}")" in
			launch.toml | build.toml | store.toml)
				continue
				;;
			*)
				if ! grep -q '^launch = true' "${layer_toml}"; then
					rm -rf "${layer_toml%.toml}" "${layer_toml}"
				fi
				;;
		esac
	done
}

process_env_files() {
	rm -f "${PROFILE_PATH}"
	find "${CNB_BUILD_DIR}/layers" -type f \( -path "*/env/*" -o -path "*/env.launch/*" \) | while read -r env_file; do
		var_name=$(basename "${env_file}" | cut -d '.' -f 1)
		operation=$(basename "${env_file}" | cut -d '.' -f 2)
		var_value=$(cat "${env_file}")
		case "${operation}" in
			"override") echo "export ${var_name}=\"${var_value}\"" ;;
			"prepend") echo "export ${var_name}=\"${var_value}\${${var_name}:+:\$${var_name}}\"" ;;
			"append") echo "export ${var_name}=\"\${${var_name}:+\$${var_name}:}${var_value}\"" ;;
			"default") echo "export ${var_name}=\"\${${var_name}:-${var_value}}\"" ;;
			*) ;;
		esac >>"${PROFILE_PATH}"
	done
}

initialize_git_submodules() {
	local repo_root="${BUILD_DIR}"
	local working_dir="${BUILD_DIR}"

	echo "-----> Checking for git submodules"

	# Check for .gitmodules in BUILD_DIR or parent directory (for monorepo with PROJECT_DIR)
	local gitmodules_file=""
	if [ -f "${BUILD_DIR}/.gitmodules" ]; then
		gitmodules_file="${BUILD_DIR}/.gitmodules"
		repo_root="${BUILD_DIR}"
	elif [ -f "${BUILD_DIR}/../.gitmodules" ]; then
		echo "       Detected monorepo structure (PROJECT_DIR in use)"
		gitmodules_file="${BUILD_DIR}/../.gitmodules"
		repo_root="${BUILD_DIR}/.."
	fi

	if [ -z "${gitmodules_file}" ]; then
		echo "       No .gitmodules file found, skipping"
		return 0
	fi

	echo "       Found .gitmodules at: ${gitmodules_file}"
	echo "-----> Cloning git submodules"

	# Parse .gitmodules and clone each submodule manually
	local current_path=""
	local current_url=""
	local current_branch=""

	while IFS= read -r line; do
		# Remove leading/trailing whitespace
		line=$(echo "${line}" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

		# Skip empty lines and comments
		[[ -z "${line}" || "${line}" =~ ^# ]] && continue

		# New submodule section
		if [[ "${line}" =~ ^\[submodule ]]; then
			# Clone previous submodule if we have the required info
			if [ -n "${current_path}" ] && [ -n "${current_url}" ]; then
				local target_dir="${repo_root}/${current_path}"
				echo "       Cloning ${current_url} into ${current_path}"
				echo "       Target directory: ${target_dir}"

				# Check if directory exists and is not empty
				if [ -d "${target_dir}" ] && [ -n "$(ls -A "${target_dir}" 2>/dev/null)" ]; then
					echo "       Submodule ${current_path} already exists and is populated, skipping"
				else
					# Remove empty directory if it exists
					[ -d "${target_dir}" ] && rm -rf "${target_dir}"

					local clone_opts=""
					[ -n "${current_branch}" ] && clone_opts="--branch ${current_branch}"

					if git clone ${clone_opts} --depth 1 "${current_url}" "${target_dir}"; then
						echo "       Successfully cloned ${current_path}"
					else
						echo " !     WARNING: Failed to clone ${current_path} from ${current_url}"
						echo " !     This might be due to SSH authentication or network issues"
					fi
				fi
			fi

			# Reset for next submodule
			current_path=""
			current_url=""
			current_branch=""

		# Parse path
		elif [[ "${line}" =~ ^path[[:space:]]*=[[:space:]]*(.*) ]]; then
			current_path="${BASH_REMATCH[1]}"

		# Parse url
		elif [[ "${line}" =~ ^url[[:space:]]*=[[:space:]]*(.*) ]]; then
			current_url="${BASH_REMATCH[1]}"

		# Parse branch
		elif [[ "${line}" =~ ^branch[[:space:]]*=[[:space:]]*(.*) ]]; then
			current_branch="${BASH_REMATCH[1]}"
		fi
	done < "${gitmodules_file}"

	# Clone the last submodule
	if [ -n "${current_path}" ] && [ -n "${current_url}" ]; then
		local target_dir="${repo_root}/${current_path}"
		echo "       Cloning ${current_url} into ${current_path}"
		echo "       Target directory: ${target_dir}"

		# Check if directory exists and is not empty
		if [ -d "${target_dir}" ] && [ -n "$(ls -A "${target_dir}" 2>/dev/null)" ]; then
			echo "       Submodule ${current_path} already exists and is populated, skipping"
		else
			# Remove empty directory if it exists
			[ -d "${target_dir}" ] && rm -rf "${target_dir}"

			local clone_opts=""
			[ -n "${current_branch}" ] && clone_opts="--branch ${current_branch}"

			if git clone ${clone_opts} --depth 1 "${current_url}" "${target_dir}"; then
				echo "       Successfully cloned ${current_path}"
			else
				echo " !     WARNING: Failed to clone ${current_path} from ${current_url}"
				echo " !     This might be due to SSH authentication or network issues"
			fi
		fi
	fi

	echo "-----> Git submodules initialized successfully"
	cd "${working_dir}"
}

fix_multiple_propertygroups() {
	echo "-----> Checking for multiple PropertyGroup elements in project files"

	# Find all .csproj, .fsproj, and .vbproj files
	find "${BUILD_DIR}" -type f \( -name "*.csproj" -o -name "*.fsproj" -o -name "*.vbproj" \) | while read -r project_file; do
		# Count PropertyGroup occurrences
		local pg_count=$(grep -c "<PropertyGroup" "${project_file}" || true)

		if [ "${pg_count}" -gt 1 ]; then
			echo "       Found ${pg_count} PropertyGroup elements in $(basename "${project_file}")"
			echo "       Creating backup and merging PropertyGroups"

			# Create backup
			cp "${project_file}" "${project_file}.backup"

			# Use awk to merge PropertyGroups while preserving conditions as comments
			awk '
			BEGIN { in_pg = 0; pg_content = ""; has_pg = 0 }
			/<PropertyGroup[^>]*>/ {
				in_pg = 1
				if ($0 ~ /Condition/) {
					# Extract condition and add as comment
					match($0, /Condition="[^"]*"/)
					condition = substr($0, RSTART, RLENGTH)
					pg_content = pg_content "  <!-- " condition " -->\n"
				}
				next
			}
			/<\/PropertyGroup>/ {
				in_pg = 0
				next
			}
			in_pg {
				pg_content = pg_content $0 "\n"
				next
			}
			!has_pg && /<Project/ {
				print $0
				print "  <PropertyGroup>"
				printf "%s", pg_content
				print "  </PropertyGroup>"
				print ""
				has_pg = 1
				next
			}
			{ print }
			' "${project_file}.backup" > "${project_file}"

			echo "       Merged PropertyGroups in $(basename "${project_file}")"
		fi
	done
}

initialize_environment
initialize_git_submodules
fix_multiple_propertygroups
download_and_extract_cnb
run_build
remove_non_launch_layers
process_env_files
